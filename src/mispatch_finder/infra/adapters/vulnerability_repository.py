from __future__ import annotations

import os
import re
from typing import Optional

from cve_collector import detail, list_vulnerabilities, clear_cache
from cve_collector.core.domain.models import Vulnerability, Repository, Commit

from ...core.ports import VulnerabilityRepositoryPort, GHSAMeta


def _normalize_repo_url(repo: str) -> str:
    if repo.startswith("http://") or repo.startswith("https://"):
        return repo[:-4] if repo.endswith(".git") else repo
    if repo.startswith("git@github.com:"):
        owner_name = repo.split(":", 1)[1]
        if owner_name.endswith(".git"):
            owner_name = owner_name[:-4]
        return f"https://github.com/{owner_name}"
    return f"https://github.com/{repo}"


def _choose_commit(commits: list[str]) -> Optional[str]:
    valid = [c for c in commits if re.fullmatch(r"[0-9a-fA-F]{7,40}", c)]
    if not valid:
        return None
    return max(valid, key=len)


class VulnerabilityRepository:
    def __init__(self, *, github_token: str) -> None:
        self._github_token = github_token
        self._ensure_token()

    def _ensure_token(self) -> None:
        if self._github_token and not os.environ.get("GITHUB_TOKEN"):
            os.environ["GITHUB_TOKEN"] = self._github_token

    def _vuln_to_meta(self, v: Vulnerability) -> Optional[GHSAMeta]:
        """Convert Vulnerability to GHSAMeta, returning None if invalid."""
        if not v.repositories:
            return None
        
        repo: Repository = v.repositories[0]
        repo_url_raw = repo.url
        if repo_url_raw is None:
            owner = repo.owner
            name = repo.name
            if owner is None or name is None:
                return None
            repo_url_raw = f"{owner}/{name}"
        repo_url = _normalize_repo_url(repo_url_raw)

        commits: tuple[Commit, ...] = v.commits
        commit_candidates: list[str] = [c.hash for c in commits]
        commit = _choose_commit(commit_candidates)
        if not commit:
            return None
        
        # Extract repo size if available (from repo metadata)
        repo_size_kb = getattr(repo, 'size', None)

        return GHSAMeta(
            ghsa=v.ghsa_id,
            repo_url=repo_url,
            commit=commit,
            parent_commit=None,
            repo_size_kb=repo_size_kb
        )
    
    def fetch_metadata(self, ghsa: str) -> GHSAMeta:
        self._ensure_token()
        v = detail(ghsa)
        if v is None:
            raise ValueError(f"GHSA not found (ghsa={ghsa})")

        meta = self._vuln_to_meta(v)
        if meta is None:
            raise ValueError(f"GHSA metadata invalid (ghsa={ghsa})")
        
        return meta

    def list_ids(self, limit: int) -> list[str]:
        self._ensure_token()
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")
        items: list[str] = []
        seen: set[str] = set()
        vulns: list[Vulnerability] = list(list_vulnerabilities(ecosystem="npm", limit=limit, detailed=False))
        for v in vulns:
            ghsa = v.ghsa_id
            if ghsa_re.match(ghsa) and ghsa not in seen:
                seen.add(ghsa)
                items.append(ghsa)
        return items
    
    def list_with_metadata(self, limit: int) -> list[GHSAMeta]:
        """List vulnerabilities with full metadata using cve_collector's detailed mode."""
        self._ensure_token()
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")
        items: list[GHSAMeta] = []
        seen: set[str] = set()
        
        # Use detailed=True to get full vulnerability data in one call
        vulns: list[Vulnerability] = list(list_vulnerabilities(ecosystem="npm", limit=limit, detailed=True))
        
        for v in vulns:
            ghsa = v.ghsa_id
            if not ghsa_re.match(ghsa) or ghsa in seen:
                continue
            
            seen.add(ghsa)
            meta = self._vuln_to_meta(v)
            if meta is not None:  # Only include valid metadata
                items.append(meta)
        
        return items

    def clear_cache(self) -> None:
        clear_cache()

