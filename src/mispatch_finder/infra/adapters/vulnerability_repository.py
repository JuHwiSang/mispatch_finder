from __future__ import annotations

import os
import re
from typing import Optional

from cve_collector import detail, list_vulnerabilities, clear_cache
import cve_collector.core.domain.models as cve_models

from ...core.domain.models import Vulnerability, Repository
from ...core.ports import VulnerabilityRepositoryPort


def _choose_commit(commits: list[str]) -> Optional[str]:
    """Select the most complete commit hash from a list of candidates."""
    valid = [c for c in commits if re.fullmatch(r"[0-9a-fA-F]{7,40}", c)]
    if not valid:
        return None
    return max(valid, key=len)


class VulnerabilityRepository:
    """Adapter that converts cve_collector models to domain models.

    Implements VulnerabilityRepositoryPort using the cve_collector library.
    Handles model conversion and validation.
    """

    def __init__(self, *, github_token: str) -> None:
        self._github_token = github_token
        self._ensure_token()

    def _ensure_token(self) -> None:
        """Ensure GITHUB_TOKEN is set in environment for cve_collector."""
        if self._github_token and not os.environ.get("GITHUB_TOKEN"):
            os.environ["GITHUB_TOKEN"] = self._github_token

    def _convert_to_domain(self, cve_vuln: cve_models.Vulnerability) -> Optional[Vulnerability]:
        """Convert cve_collector.Vulnerability to domain.Vulnerability.

        Args:
            cve_vuln: External vulnerability model from cve_collector

        Returns:
            Domain Vulnerability model, or None if conversion fails

        Conversion rules:
        - Uses first repository from the list
        - Selects most complete commit hash
        - Converts repo size from bytes to KB
        - Extracts severity string representation
        """
        if not cve_vuln.repositories:
            return None

        cve_repo: cve_models.Repository = cve_vuln.repositories[0]

        # Validate required repository fields
        if cve_repo.owner is None or cve_repo.name is None:
            return None

        # Select commit
        if not cve_vuln.commits:
            return None

        commit_candidates: list[str] = [c.hash for c in cve_vuln.commits]
        commit_hash = _choose_commit(commit_candidates)
        if not commit_hash:
            return None

        # Convert repo size from bytes to KB
        size_kb: Optional[int] = None
        if cve_repo.size_bytes is not None:
            size_kb = cve_repo.size_bytes // 1024

        # Build domain models
        repo = Repository(
            owner=cve_repo.owner,
            name=cve_repo.name,
            ecosystem=cve_repo.ecosystem,
            star_count=cve_repo.star_count,
            size_kb=size_kb,
        )

        # Extract severity string (e.g., "CRITICAL", "HIGH")
        severity_str: Optional[str] = None
        if cve_vuln.severity is not None:
            severity_str = str(cve_vuln.severity.value) if hasattr(cve_vuln.severity, 'value') else str(cve_vuln.severity)

        return Vulnerability(
            ghsa_id=cve_vuln.ghsa_id,
            repository=repo,
            commit_hash=commit_hash,
            cve_id=cve_vuln.cve_id,
            summary=cve_vuln.summary,
            severity=severity_str,
        )

    def fetch_metadata(self, ghsa: str) -> Vulnerability:
        """Fetch and convert vulnerability metadata for a specific GHSA."""
        self._ensure_token()
        cve_vuln = detail(ghsa)
        if cve_vuln is None:
            raise ValueError(f"GHSA not found (ghsa={ghsa})")

        domain_vuln = self._convert_to_domain(cve_vuln)
        if domain_vuln is None:
            raise ValueError(f"GHSA metadata invalid (ghsa={ghsa})")

        return domain_vuln

    def list_ids(self, limit: int, ecosystem: str = "npm") -> list[str]:
        """List GHSA IDs using cve_collector.list_vulnerabilities(detailed=False).

        Args:
            limit: Maximum number of IDs to return
            ecosystem: Ecosystem to filter by (npm, pypi, etc.)

        Returns:
            List of valid GHSA identifiers
        """
        self._ensure_token()
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")
        items: list[str] = []
        seen: set[str] = set()

        vulns = list_vulnerabilities(ecosystem=ecosystem, limit=limit, detailed=False)
        for cve_vuln in vulns:
            ghsa = cve_vuln.ghsa_id
            if ghsa_re.match(ghsa) and ghsa not in seen:
                seen.add(ghsa)
                items.append(ghsa)
        return items

    def list_with_metadata(self, limit: int, ecosystem: str = "npm") -> list[Vulnerability]:
        """List vulnerabilities with full metadata.

        More efficient than calling fetch_metadata() individually,
        as it retrieves all data (OSV + GitHub enrichment) in batched operations.

        Args:
            limit: Maximum number of vulnerabilities to return
            ecosystem: Ecosystem to filter by (npm, pypi, etc.)

        Returns:
            List of domain Vulnerability objects
        """
        self._ensure_token()
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")
        items: list[Vulnerability] = []
        seen: set[str] = set()

        # Use detailed=True to get enriched vulnerability data in one call
        vulns = list_vulnerabilities(ecosystem=ecosystem, limit=limit, detailed=True)

        for cve_vuln in vulns:
            ghsa = cve_vuln.ghsa_id
            if not ghsa_re.match(ghsa) or ghsa in seen:
                continue

            seen.add(ghsa)
            domain_vuln = self._convert_to_domain(cve_vuln)
            if domain_vuln is not None:  # Only include valid metadata
                items.append(domain_vuln)

        return items

    def clear_cache(self, prefix: Optional[str] = None) -> None:
        """Clear cve_collector cache using prefix-based filtering.

        Args:
            prefix: Cache key prefix to clear:
                - None: Clear all caches
                - "osv": Clear only OSV vulnerability data
                - "gh_repo": Clear only GitHub repository metadata
        """
        clear_cache(prefix=prefix)
