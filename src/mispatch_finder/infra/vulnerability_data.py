from __future__ import annotations

import os
import re
from typing import Optional, Union

from cve_collector import detail, list_vulnerabilities, clear_cache
import cve_collector.core.domain.models as cve_models

from ..core.domain.models import Vulnerability, Repository
from ..core.ports import VulnerabilityDataPort


def _choose_commit(commits: list[str]) -> Optional[str]:
    """Select the most complete commit hash from a list of candidates."""
    valid = [c for c in commits if re.fullmatch(r"[0-9a-fA-F]{7,40}", c)]
    if not valid:
        return None
    return max(valid, key=len)


class VulnerabilityDataAdapter(VulnerabilityDataPort):
    """Adapter that converts cve_collector models to domain models.

    Implements VulnerabilityDataPort using the cve_collector library.
    Handles model conversion and validation.
    """

    def __init__(self, *, github_token: str) -> None:
        self._github_token = github_token
        self._ensure_token()

    def _ensure_token(self) -> None:
        """Ensure GITHUB_TOKEN is set in environment for cve_collector."""
        if self._github_token and not os.environ.get("GITHUB_TOKEN"):
            os.environ["GITHUB_TOKEN"] = self._github_token

    def _convert_to_domain(self, cve_vuln: cve_models.Vulnerability) -> Optional[Vulnerability]:
        """Convert cve_collector.Vulnerability to domain.Vulnerability.

        Args:
            cve_vuln: External vulnerability model from cve_collector

        Returns:
            Domain Vulnerability model, or None if conversion fails

        Conversion rules:
        - Uses first repository from the list
        - Selects most complete commit hash
        - Converts repo size from bytes to KB
        - Extracts severity string representation
        """
        if not cve_vuln.repositories:
            return None

        cve_repo: cve_models.Repository = cve_vuln.repositories[0]

        # Validate required repository fields
        if cve_repo.owner is None or cve_repo.name is None:
            return None

        # Select commit
        if not cve_vuln.commits:
            return None

        commit_candidates: list[str] = [c.hash for c in cve_vuln.commits]
        commit_hash = _choose_commit(commit_candidates)
        if not commit_hash:
            return None

        # Convert repo size from bytes to KB
        size_kb: Optional[int] = None
        if cve_repo.size_bytes is not None:
            size_kb = cve_repo.size_bytes // 1024

        # Build domain models
        repo = Repository(
            owner=cve_repo.owner,
            name=cve_repo.name,
            ecosystem=cve_repo.ecosystem,
            star_count=cve_repo.star_count,
            size_kb=size_kb,
        )

        # Extract severity string (e.g., "CRITICAL", "HIGH")
        severity_str: Optional[str] = None
        if cve_vuln.severity is not None:
            severity_str = str(cve_vuln.severity.value) if hasattr(cve_vuln.severity, 'value') else str(cve_vuln.severity)

        return Vulnerability(
            ghsa_id=cve_vuln.ghsa_id,
            repository=repo,
            commit_hash=commit_hash,
            cve_id=cve_vuln.cve_id,
            summary=cve_vuln.summary,
            severity=severity_str,
        )

    def fetch_metadata(self, ghsa: str) -> Vulnerability:
        """Fetch and convert vulnerability metadata for a specific GHSA."""
        self._ensure_token()
        cve_vuln = detail(ghsa)
        if cve_vuln is None:
            raise ValueError(f"GHSA not found (ghsa={ghsa})")

        domain_vuln = self._convert_to_domain(cve_vuln)
        if domain_vuln is None:
            raise ValueError(f"GHSA metadata invalid (ghsa={ghsa})")

        return domain_vuln

    def list_vulnerabilities(
        self,
        limit: int,
        ecosystem: str = "npm",
        detailed: bool = False,
        filter_expr: Optional[str] = None,
    ) -> Union[list[str], list[Vulnerability]]:
        """List vulnerabilities with optional detailed metadata.

        Args:
            limit: Maximum number of items to return
            ecosystem: Ecosystem to filter by (npm, pypi, go, etc.)
            detailed: If True, return full Vulnerability objects; if False, return GHSA IDs only
            filter_expr: Optional asteval filter expression for filtering results

        Returns:
            list[str] if detailed=False (GHSA IDs only)
            list[Vulnerability] if detailed=True (full domain models)
        """
        self._ensure_token()
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")

        vulns = list_vulnerabilities(
            ecosystem=ecosystem,
            limit=limit,
            detailed=detailed,
            filter_expr=filter_expr,
        )

        if not detailed:
            # Return only GHSA IDs (deduplicated)
            items: list[str] = []
            seen: set[str] = set()
            for cve_vuln in vulns:
                ghsa = cve_vuln.ghsa_id
                if ghsa_re.match(ghsa) and ghsa not in seen:
                    seen.add(ghsa)
                    items.append(ghsa)
            return items
        else:
            # Return full domain models (skip invalid ones)
            results: list[Vulnerability] = []
            seen_ids: set[str] = set()
            for cve_vuln in vulns:
                ghsa = cve_vuln.ghsa_id
                if not ghsa_re.match(ghsa) or ghsa in seen_ids:
                    continue
                seen_ids.add(ghsa)

                domain_vuln = self._convert_to_domain(cve_vuln)
                if domain_vuln is not None:
                    results.append(domain_vuln)
            return results

    def clear_cache(self, prefix: Optional[str] = None) -> None:
        """Clear cve_collector cache using prefix-based filtering.

        Args:
            prefix: Cache key prefix to clear:
                - None: Clear all caches
                - "osv": Clear only OSV vulnerability data
                - "gh_repo": Clear only GitHub repository metadata
        """
        clear_cache(prefix=prefix)
