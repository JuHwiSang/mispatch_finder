from __future__ import annotations

import re
from pathlib import Path
from typing import Iterator

import cve_collector.core.domain.models as cve_models
from cve_collector import CveCollectorClient

from ..core.domain.models import Repository, Vulnerability
from ..core.ports import VulnerabilityDataPort


def _choose_commit(commits: list[str]) -> str | None:
    """Select the most complete commit hash from a list of candidates."""
    valid = [c for c in commits if re.fullmatch(r"[0-9a-fA-F]{7,40}", c)]
    if not valid:
        return None
    return max(valid, key=len)


class VulnerabilityDataAdapter(VulnerabilityDataPort):
    """Adapter that converts cve_collector models to domain models.

    Implements VulnerabilityDataPort using the cve_collector library.
    Handles model conversion and validation.
    """

    def __init__(
        self,
        *,
        github_token: str,
        cache_dir: Path | None = None,
        github_cache_ttl_days: int | None = None,
        osv_cache_ttl_days: int | None = None,
    ) -> None:
        self._client = CveCollectorClient(
            github_token=github_token,
            cache_dir=cache_dir,
            github_cache_ttl_days=github_cache_ttl_days,
            osv_cache_ttl_days=osv_cache_ttl_days,
        )

    def _convert_to_domain(self, cve_vuln: cve_models.Vulnerability) -> Vulnerability | None:
        """Convert cve_collector.Vulnerability to domain.Vulnerability.

        Args:
            cve_vuln: External vulnerability model from cve_collector

        Returns:
            Domain Vulnerability model, or None if conversion fails

        Conversion rules:
        - Uses first repository from the list
        - Selects most complete commit hash
        - Converts repo size from bytes to KB
        - Extracts severity string representation
        """
        if not cve_vuln.repositories:
            return None

        cve_repo: cve_models.Repository = cve_vuln.repositories[0]

        # Validate required repository fields
        if cve_repo.owner is None or cve_repo.name is None:
            return None

        # Select commit
        if not cve_vuln.commits:
            return None

        commit_candidates: list[str] = [c.hash for c in cve_vuln.commits]
        commit_hash = _choose_commit(commit_candidates)
        if not commit_hash:
            return None

        # Convert repo size from bytes to KB
        size_kb: int | None = None
        if cve_repo.size_bytes is not None:
            size_kb = cve_repo.size_bytes // 1024

        # Build domain models
        repo = Repository(
            owner=cve_repo.owner,
            name=cve_repo.name,
            ecosystem=cve_repo.ecosystem,
            star_count=cve_repo.star_count,
            size_kb=size_kb,
        )

        # Extract severity string (e.g., "CRITICAL", "HIGH")
        severity_str: str | None = None
        if cve_vuln.severity is not None:
            severity_str = str(cve_vuln.severity.value) if hasattr(cve_vuln.severity, 'value') else str(cve_vuln.severity)

        return Vulnerability(
            ghsa_id=cve_vuln.ghsa_id,
            repository=repo,
            commit_hash=commit_hash,
            cve_id=cve_vuln.cve_id,
            summary=cve_vuln.summary,
            severity=severity_str,
        )

    def fetch_metadata(self, ghsa: str) -> Vulnerability:
        """Fetch and convert vulnerability metadata for a specific GHSA."""
        cve_vuln = self._client.detail(ghsa)
        if cve_vuln is None:
            raise ValueError(f"GHSA not found (ghsa={ghsa})")

        domain_vuln = self._convert_to_domain(cve_vuln)
        if domain_vuln is None:
            raise ValueError(f"GHSA metadata invalid (ghsa={ghsa})")

        return domain_vuln

    def list_vulnerabilities(
        self,
        limit: int,
        ecosystem: str = "npm",
        detailed: bool = False,
        filter_expr: str | None = None,
    ) -> list[str] | list[Vulnerability]:
        """List vulnerabilities with optional detailed metadata.

        Args:
            limit: Maximum number of items to return
            ecosystem: Ecosystem to filter by (npm, pypi, go, etc.)
            detailed: If True, return full Vulnerability objects; if False, return GHSA IDs only
            filter_expr: Optional asteval filter expression for filtering results

        Returns:
            list[str] if detailed=False (GHSA IDs only)
            list[Vulnerability] if detailed=True (full domain models)
        """
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")

        vulns = self._client.list_vulnerabilities(
            ecosystem=ecosystem,
            limit=limit,
            detailed=detailed,
            filter_expr=filter_expr,
        )

        if not detailed:
            # Return only GHSA IDs (deduplicated)
            items: list[str] = []
            seen: set[str] = set()
            for cve_vuln in vulns:
                ghsa = cve_vuln.ghsa_id
                if ghsa_re.match(ghsa) and ghsa not in seen:
                    seen.add(ghsa)
                    items.append(ghsa)
            return items
        else:
            # Return full domain models (skip invalid ones)
            results: list[Vulnerability] = []
            seen_ids: set[str] = set()
            for cve_vuln in vulns:
                ghsa = cve_vuln.ghsa_id
                if not ghsa_re.match(ghsa) or ghsa in seen_ids:
                    continue
                seen_ids.add(ghsa)

                domain_vuln = self._convert_to_domain(cve_vuln)
                if domain_vuln is not None:
                    results.append(domain_vuln)
            return results

    def list_vulnerabilities_iter(
        self,
        ecosystem: str = "npm",
        detailed: bool = False,
        filter_expr: str | None = None,
    ) -> Iterator[str] | Iterator[Vulnerability]:
        """Iterate over vulnerabilities lazily.

        Args:
            ecosystem: Ecosystem to filter by (npm, pypi, go, etc.)
            detailed: If True, yield full Vulnerability objects; if False, yield GHSA IDs only
            filter_expr: Optional asteval filter expression for filtering results

        Yields:
            str if detailed=False (GHSA IDs)
            Vulnerability if detailed=True (full domain models)
        """
        ghsa_re = re.compile(r"^GHSA-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+-[A-Za-z0-9_-]+$")
        seen: set[str] = set()

        for cve_vuln in self._client.list_vulnerabilities_iter(
            ecosystem=ecosystem,
            detailed=detailed,
            filter_expr=filter_expr,
        ):
            ghsa = cve_vuln.ghsa_id
            if not ghsa_re.match(ghsa) or ghsa in seen:
                continue
            seen.add(ghsa)

            if not detailed:
                yield ghsa
            else:
                domain_vuln = self._convert_to_domain(cve_vuln)
                if domain_vuln is not None:
                    yield domain_vuln

    def clear_cache(self, prefix: str | None = None) -> None:
        """Clear cve_collector cache using prefix-based filtering.

        Args:
            prefix: Cache key prefix to clear:
                - None: Clear all caches
                - "osv": Clear only OSV vulnerability data
                - "gh_repo": Clear only GitHub repository metadata
        """
        self._client.clear_cache(prefix=prefix)
